# 트랜잭션이란
논리적인 작업 셋을 모두 완벽하게 처리하거나, 또는 처리하지 못했을 경우 원 상태로 복구해 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. - 즉 완전성을 보장해주는것!!
사용자의 입장에선 작업의 논리적 작업단위로 이해하고

시스템의 입장에선 데이터들을 접근 또는 변경하는 프로그램의 단위로 이해한다.

트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업단위(를 구성하는 연산들의 집합)

여기서 DB의 상태변화란 SQL질의어를 통해 db에 접근하는것을 의미하는데  select, insert, delete, update 가 있다.
- 위에서 말하는 작업단위는 - 많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는것을 말한다.
예) A계좌에서 B계좌로 돈을 이체할 때
1. A계좌의 잔액을 확인한다.
2. A계좌에서 이체할 금액을 뺀 나머지를 저장한다.
3. B계좌의 잔액을 확인한다.
4. B계좌에서 이체할 금액을 더한 금액을 저장한다.

위 예시는 출금에 대한 UPDATE와 입금에 대한 UPDATE문이 사용이 되었는데 이를 통틀어서 계좌이체라는 하나의 트랙잭션을 구성한것이다.

하나의 트랜잭션은 Commit되거나 Rollback되는데  
- Commit - 입출금 UPDATE 모두 성공적으로 완료되는것 (정상적으로 완료된다면 연산을 마치고 최종적으로는 트랜잭션 관리자에게 알려준다.)

- Rollback - 작업 단위에 속하는 쿼리중 하나라도 실패한다면 모든 쿼리문을 취소하고 이전상태로 돌려놓는것을 의미 (이 때는 해당 트랜잭션을 재시작하거나 폐기한다.)

# 트랜잭션 특징(ACID) - 트랜잭션은 아래의 4가지 특징을 만족해야한다.
- **원자성(Atomicity)**
트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야한다. 즉 중간에 오류가 발생한다면 트랜잭션에 해당하는 어떠한 작업도 수행되서는 안된다.
- **일관성(Consistency)**
트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
- **고립성(Isolation)**
각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. 즉 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
- **지속성(Durability)**
트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.


# 트랜잭션의 상태
![transaction](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/transaction-status.png)
- Active(활동)
트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태
- Partially committed(부분 완료)
트랜잭션의 commit 명령이 도착한 상태, 트랜잭션의 commit이전 sql문이 실행되고 commit만 남은상태 = 즉 commit 명령이 실행되기 직전 상태
- Failed(장애)
트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태
- Committed(완료)
트랜잭션 완료상태
- Aborted(철회)
트랜잭션 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태

## 트랜잭션 사용할 때 주의할 점
트랜잭션은 꼭 필요한 최소의 코드에만 작성하는게 좋다.(트랜잭션의 범위를 최소화시켜라) 
일반적으로 데이터베이스의 커넥션은 개수가 제한적인데, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간부터는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.


# 트랜잭션 격리수준
Isolation Level
- 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준

Isolation Level 의 필요성
- 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다.
- 그래서 Locking 이라는 개념이 등장한다.
    - 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것
- 하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다.
- 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 여지가 있다.
- 그래서 최대한 효율적인 Locking 방법이 필요하다.

**Isolation Level의 종류(0 ~ 3까지 총 4단계)**
**Read Uncommitted (레벨 0)**
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.데이터베이스의 일관성을 유지할 수 없다.

**Read Committed (레벨 1)**
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.Commit이 이루어진 트랜잭션만 조회할 수 있다.따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.SQL Server가 Default로 사용하는 Isolation Level

**Repeatable Read (레벨 2)**
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다.

**Serializable (레벨 3)**
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level완벽한 읽기 일관성 모드를 제공한다.따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.

Isolation level 조정은 동시성이 증가되는데 반해 데이터 무결성에 문제가 발생할 수 있고, 데이터의 무결성을 유지하는 데 반해 동시성이 떨어질 수 있다.
레벨이 높아질수록 비용이 높아진다.

# 트랜잭션과 Lock
잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 여기서 자원은 레코드나 테이블을 말한다. 이와는 조금 다르게 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.
